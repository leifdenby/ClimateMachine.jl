<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flow in Single Element Stack · ClimateMachine</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="ClimateMachine logo"/></a><div class="docs-package-name"><span class="docs-autofit">ClimateMachine</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../GettingStarted/Installation/">Installation</a></li><li><a class="tocitem" href="../../../GettingStarted/RunningClimateMachine/">Running</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Defaults</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../GettingStarted/Atmos/">Atmosphere model configurations</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heldsuarez/">Dry Idealized GCM</a></li><li class="is-active"><a class="tocitem" href>Flow in Single Element Stack</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Preliminary-configuration-1"><span>Preliminary configuration</span></a></li><li><a class="tocitem" href="#Loading-code-burgers-1"><span>Loading code</span></a></li><li><a class="tocitem" href="#Initialization-1"><span>Initialization</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1"><span>Define the set of Partial Differential Equations (PDEs)</span></a></li><li><a class="tocitem" href="#Define-the-model-1"><span>Define the model</span></a></li><li><a class="tocitem" href="#Define-the-variables-1"><span>Define the variables</span></a></li><li><a class="tocitem" href="#Define-the-compute-kernels-1"><span>Define the compute kernels</span></a></li><li class="toplevel"><a class="tocitem" href="#Spatial-discretization-1"><span>Spatial discretization</span></a></li><li class="toplevel"><a class="tocitem" href="#Time-discretization-1"><span>Time discretization</span></a></li><li class="toplevel"><a class="tocitem" href="#Configure-a-ClimateMachine-solver.-1"><span>Configure a <code>ClimateMachine</code> solver.</span></a></li><li><a class="tocitem" href="#Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1"><span>Inspect the initial conditions for a single node (e.g. the southwest node)</span></a></li><li><a class="tocitem" href="#Inspect-the-initial-conditions-for-the-horizontal-average-1"><span>Inspect the initial conditions for the horizontal average</span></a></li><li class="toplevel"><a class="tocitem" href="#Solver-hooks-/-callbacks-1"><span>Solver hooks / callbacks</span></a></li><li class="toplevel"><a class="tocitem" href="#Solve-1"><span>Solve</span></a></li><li class="toplevel"><a class="tocitem" href="#Post-processing-1"><span>Post-processing</span></a></li></ul></li><li><a class="tocitem" href="../agnesi_hs_lin/">Linear Hydrostatic Mountain (Topography)</a></li><li><a class="tocitem" href="../agnesi_nh_lin/">Linear Non-Hydrostatic Mountain (Topography)</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-3-1"><span class="docs-label">Heat</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Land/Heat/heat_equation/">Heat Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-4-1" type="checkbox"/><label class="tocitem" for="menuitem-3-4-1"><span class="docs-label">System Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Numerics/SystemSolvers/cg/">Conjugate Gradient</a></li><li><a class="tocitem" href="../../Numerics/SystemSolvers/bgmres/">Batched Generalized Minimal Residual</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">DG Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topo/">Topology</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-5-1" type="checkbox"/><label class="tocitem" for="menuitem-3-5-1"><span class="docs-label">Debug</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Diagnostics/Debug/StateCheck/">State Statistics Regression</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../literate_markdown/">Notes on Literate</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to-guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Common/Thermodynamics/">Thermodynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Atmos/TemperatureProfiles/">TemperatureProfiles</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><span class="tocitem">Meshes</span></li><li><input class="collapse-toggle" id="menuitem-4-5-2" type="checkbox"/><label class="tocitem" for="menuitem-4-5-2"><span class="docs-label">DG methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/">How to make a balance law</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-3" type="checkbox"/><label class="tocitem" for="menuitem-4-5-3"><span class="docs-label">ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Numerics/ODESolvers/Timestepping/">Time-integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-4" type="checkbox"/><label class="tocitem" for="menuitem-4-5-4"><span class="docs-label">System Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../HowToGuides/Numerics/SystemSolvers/IterativeSolvers/">Iterative Solvers</a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/">Home</a></li><li><a class="tocitem" href="../../../APIs/Driver/">Driver</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../APIs/Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../APIs/Atmos/TemperatureProfiles/">Temperature Profiles</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Ocean</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Ocean/HydrostaticBoussinesq/">Hydrostatic Boussinesq</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Land/LandModel/">Land Model</a></li><li><a class="tocitem" href="../../../APIs/Land/SoilWaterParameterizations/">Soil Water Parameterizations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Common/Orientations/">Orientations</a></li><li><a class="tocitem" href="../../../APIs/Common/SurfaceFluxes/">Surface Fluxes</a></li><li><a class="tocitem" href="../../../APIs/Common/Thermodynamics/">Thermodynamics</a></li><li><a class="tocitem" href="../../../APIs/Common/TurbulenceClosures/">Turbulence Closures</a></li><li><a class="tocitem" href="../../../APIs/Common/TurbulenceConvection/">Turbulence Convection</a></li></ul></li><li><a class="tocitem" href="../../../APIs/BalanceLaws/BalanceLaws/">Balance Laws</a></li><li><a class="tocitem" href="../../../APIs/Arrays/Arrays/">Arrays</a></li><li><input class="collapse-toggle" id="menuitem-5-9" type="checkbox"/><label class="tocitem" for="menuitem-5-9"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Diagnostics/Diagnostics/">Diagnostics groups</a></li><li><a class="tocitem" href="../../../APIs/Diagnostics/StateCheck/">State Check</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-10" type="checkbox"/><label class="tocitem" for="menuitem-5-10"><span class="docs-label">Input/Output</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/InputOutput/">Input/Output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-11" type="checkbox"/><label class="tocitem" for="menuitem-5-11"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Numerics/Meshes/Mesh/">Meshes</a></li><li><a class="tocitem" href="../../../APIs/Numerics/SystemSolvers/SystemSolvers/">SystemSolvers</a></li><li><a class="tocitem" href="../../../APIs/Numerics/ODESolvers/ODESolvers/">ODESolvers</a></li><li><a class="tocitem" href="../../../APIs/Numerics/DGMethods/DGMethods/">DG Methods</a></li><li><a class="tocitem" href="../../../APIs/Numerics/DGMethods/Courant/">Courant</a></li><li><a class="tocitem" href="../../../APIs/Numerics/DGMethods/NumericalFluxes/">Numerical Fluxes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-12" type="checkbox"/><label class="tocitem" for="menuitem-5-12"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/Utilities/VariableTemplates/">Variable Templates</a></li><li><a class="tocitem" href="../../../APIs/Utilities/SingleStackUtils/">Single Stack Utilities</a></li><li><a class="tocitem" href="../../../APIs/Utilities/Checkpoint/">Checkpoint</a></li><li><a class="tocitem" href="../../../APIs/Utilities/TicToc/">Tic Toc</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../Contributing/">Contribution guide</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Theory/Common/SurfaceFluxes/">SurfaceFluxes</a></li><li><a class="tocitem" href="../../../Theory/Common/Turbulence/">Turbulence Closures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Theory/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../Theory/Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../Theory/Atmos/EDMFEquations/">EDMF equations</a></li><li><a class="tocitem" href="../../../Theory/Atmos/Model/tracers/">Tracers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DevDocs/CodeStyle/">Coding style</a></li><li><a class="tocitem" href="../../../DevDocs/AcceptableUnicode/">Acceptable Unicode</a></li><li><a class="tocitem" href="../../../DevDocs/VariableList/">Variable list</a></li><li><a class="tocitem" href="../../../DevDocs/DiagnosticVariables/">Diagnostic variable list</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Atmos</a></li><li class="is-active"><a href>Flow in Single Element Stack</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Flow in Single Element Stack</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/burgers_single_stack.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations-1"><a class="docs-heading-anchor" href="#Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations-1">Single stack tutorial based on the 3D Burgers + tracer equations</a><a class="docs-heading-anchor-permalink" href="#Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations-1" title="Permalink"></a></h1><p>Equations solved in balance law form:</p><div>\[\begin{align}
\frac{∂ ρ}{∂ t} =&amp; - ∇ ⋅ (ρ\mathbf{u}) \\
\frac{∂ ρ\mathbf{u}}{∂ t} =&amp; - ∇ ⋅ (-μ ∇\mathbf{u}) - ∇ ⋅ (ρ\mathbf{u} \mathbf{u}&#39;) - γ[ (ρ\mathbf{u}-ρ̄\mathbf{ū}) - (ρ\mathbf{u}-ρ̄\mathbf{ū})⋅ẑ ẑ] \\
\frac{∂ ρcT}{∂ t} =&amp; - ∇ ⋅ (-α ∇ρcT) - ∇ ⋅ (\mathbf{u} ρcT)
\end{align}\]</div><p>Boundary conditions:</p><div>\[\begin{align}
z_{\mathrm{min}}: &amp; ρ = 1 \\
z_{\mathrm{min}}: &amp; ρ\mathbf{u} = \mathbf{0} \\
z_{\mathrm{min}}: &amp; ρcT = ρc T_{\mathrm{fixed}} \\
z_{\mathrm{max}}: &amp; ρ = 1 \\
z_{\mathrm{max}}: &amp; ρ\mathbf{u} = \mathbf{0} \\
z_{\mathrm{max}}: &amp; -α∇ρcT = 0
\end{align}\]</div><p>where</p><ul><li><span>$t$</span> is time</li><li><span>$ρ$</span> is the density</li><li><span>$\mathbf{u}$</span> is the velocity (vector)</li><li><span>$\mathbf{ū}$</span> is the horizontally averaged velocity (vector)</li><li><span>$μ$</span> is the dynamic viscosity tensor</li><li><span>$γ$</span> is the Rayleigh friction frequency</li><li><span>$T$</span> is the temperature</li><li><span>$α$</span> is the thermal diffusivity</li><li><span>$c$</span> is the heat capacity</li><li><span>$ρcT$</span> is the thermal energy</li></ul><p>Solving these equations is broken down into the following steps:</p><ol><li>Preliminary configuration</li><li>PDEs</li><li>Space discretization</li><li>Time discretization</li><li>Solver hooks / callbacks</li><li>Solve</li><li>Post-processing</li></ol><h1 id="Preliminary-configuration-1"><a class="docs-heading-anchor" href="#Preliminary-configuration-1">Preliminary configuration</a><a class="docs-heading-anchor-permalink" href="#Preliminary-configuration-1" title="Permalink"></a></h1><h2 id="Loading-code-burgers-1"><a class="docs-heading-anchor" href="#Loading-code-burgers-1">Loading code</a><a class="docs-heading-anchor-permalink" href="#Loading-code-burgers-1" title="Permalink"></a></h2><p>First, we&#39;ll load our pre-requisites</p><ul><li>load external packages:</li></ul><pre><code class="language-julia">using MPI
using Distributions
using NCDatasets
using OrderedCollections
using Plots
using StaticArrays
using LinearAlgebra: Diagonal</code></pre><ul><li>load CLIMAParameters and set up to use it:</li></ul><pre><code class="language-julia">using CLIMAParameters
struct EarthParameterSet &lt;: AbstractEarthParameterSet end
const param_set = EarthParameterSet()</code></pre><pre><code class="language-none">Main.ex-burgers_single_stack.EarthParameterSet()</code></pre><ul><li>load necessary ClimateMachine modules:</li></ul><pre><code class="language-julia">using ClimateMachine
using ClimateMachine.Mesh.Topologies
using ClimateMachine.Mesh.Grids
using ClimateMachine.Writers
using ClimateMachine.DGMethods
using ClimateMachine.DGMethods.NumericalFluxes
using ClimateMachine.Mesh.Geometry: LocalGeometry
using ClimateMachine.MPIStateArrays
using ClimateMachine.GenericCallbacks
using ClimateMachine.ODESolvers
using ClimateMachine.VariableTemplates
using ClimateMachine.SingleStackUtils</code></pre><ul><li>import necessary ClimateMachine modules: (<code>import</code>ing enables us to</li></ul><p>provide implementations of these structs/methods)</p><pre><code class="language-julia">using ClimateMachine.BalanceLaws
import ClimateMachine.BalanceLaws:
    vars_state,
    source!,
    flux_second_order!,
    flux_first_order!,
    compute_gradient_argument!,
    compute_gradient_flux!,
    update_auxiliary_state!,
    nodal_update_auxiliary_state!,
    init_state_auxiliary!,
    init_state_prognostic!,
    boundary_state!</code></pre><h2 id="Initialization-1"><a class="docs-heading-anchor" href="#Initialization-1">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-1" title="Permalink"></a></h2><p>Define the float type (<code>Float64</code> or <code>Float32</code>)</p><pre><code class="language-julia">FT = Float64;</code></pre><p>Initialize ClimateMachine for CPU.</p><pre><code class="language-julia">ClimateMachine.init(; disable_gpu = true);

const clima_dir = dirname(dirname(pathof(ClimateMachine)));</code></pre><p>Load some helper functions for plotting</p><pre><code class="language-julia">include(joinpath(clima_dir, &quot;docs&quot;, &quot;plothelpers.jl&quot;));</code></pre><h1 id="Define-the-set-of-Partial-Differential-Equations-(PDEs)-1"><a class="docs-heading-anchor" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1">Define the set of Partial Differential Equations (PDEs)</a><a class="docs-heading-anchor-permalink" href="#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1" title="Permalink"></a></h1><h2 id="Define-the-model-1"><a class="docs-heading-anchor" href="#Define-the-model-1">Define the model</a><a class="docs-heading-anchor-permalink" href="#Define-the-model-1" title="Permalink"></a></h2><p>Model parameters can be stored in the particular <a href="../../../APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.BalanceLaw"><code>BalanceLaw</code></a>, in this case, the <code>BurgersEquation</code>:</p><pre><code class="language-julia">Base.@kwdef struct BurgersEquation{FT} &lt;: BalanceLaw
    &quot;Parameters&quot;
    param_set::AbstractParameterSet = param_set
    &quot;Heat capacity&quot;
    c::FT = 1
    &quot;Vertical dynamic viscosity&quot;
    μv::FT = 1e-4
    &quot;Horizontal dynamic viscosity&quot;
    μh::FT = 1e-2
    &quot;Thermal diffusivity&quot;
    α::FT = 0.01
    &quot;IC Gaussian noise standard deviation&quot;
    σ::FT = 1e-1
    &quot;Rayleigh damping&quot;
    γ::FT = μh / 0.08 / 1e-2 / 1e-2
    &quot;Domain height&quot;
    zmax::FT = 1
    &quot;Initial conditions for temperature&quot;
    initialT::FT = 295.15
    &quot;Bottom boundary value for temperature (Dirichlet boundary conditions)&quot;
    T_bottom::FT = 300.0
    &quot;Top flux (α∇ρcT) at top boundary (Neumann boundary conditions)&quot;
    flux_top::FT = 0.0
end</code></pre><p>Create an instance of the <code>BurgersEquation</code>:</p><pre><code class="language-julia">m = BurgersEquation{FT}();</code></pre><p>This model dictates the flow control, using <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">Dynamic Multiple Dispatch</a>, for which kernels are executed.</p><h2 id="Define-the-variables-1"><a class="docs-heading-anchor" href="#Define-the-variables-1">Define the variables</a><a class="docs-heading-anchor-permalink" href="#Define-the-variables-1" title="Permalink"></a></h2><p>All of the methods defined in this section were <code>import</code>ed in <a href="#Loading-code-burgers-1">Loading code</a> to let us provide implementations for our <code>BurgersEquation</code> as they will be used by the solver.</p><p>Specify auxiliary variables for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state(::BurgersEquation, ::Auxiliary, FT) = @vars(z::FT, T::FT);</code></pre><p>Specify state variables, the variables solved for in the PDEs, for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state(::BurgersEquation, ::Prognostic, FT) =
    @vars(ρ::FT, ρu::SVector{3, FT}, ρcT::FT);</code></pre><p>Specify state variables whose gradients are needed for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state(::BurgersEquation, ::Gradient, FT) =
    @vars(u::SVector{3, FT}, ρcT::FT);</code></pre><p>Specify gradient variables for <code>BurgersEquation</code></p><pre><code class="language-julia">vars_state(::BurgersEquation, ::GradientFlux, FT) =
    @vars(μ∇u::SMatrix{3, 3, FT, 9}, α∇ρcT::SVector{3, FT});</code></pre><h2 id="Define-the-compute-kernels-1"><a class="docs-heading-anchor" href="#Define-the-compute-kernels-1">Define the compute kernels</a><a class="docs-heading-anchor-permalink" href="#Define-the-compute-kernels-1" title="Permalink"></a></h2><p>Specify the initial values in <code>aux::Vars</code>, which are available in <code>init_state_prognostic!</code>. Note that</p><ul><li>this method is only called at <code>t=0</code></li><li><code>aux.z</code> and <code>aux.T</code> are available here because we&#39;ve specified <code>z</code> and <code>T</code></li></ul><p>in <code>vars_state</code></p><pre><code class="language-julia">function init_state_auxiliary!(
    m::BurgersEquation,
    aux::Vars,
    geom::LocalGeometry,
)
    aux.z = geom.coord[3]
    aux.T = m.initialT
end;</code></pre><p>Specify the initial values in <code>state::Vars</code>. Note that</p><ul><li>this method is only called at <code>t=0</code></li><li><code>state.ρ</code>, <code>state.ρu</code> and<code>state.ρcT</code> are available here because</li></ul><p>we&#39;ve specified <code>ρ</code>, <code>ρu</code> and <code>ρcT</code> in <code>vars_state</code></p><pre><code class="language-julia">function init_state_prognostic!(
    m::BurgersEquation,
    state::Vars,
    aux::Vars,
    coords,
    t::Real,
)
    z = aux.z
    ε1 = rand(Normal(0, m.σ))
    ε2 = rand(Normal(0, m.σ))
    state.ρ = 1
    ρu = 1 - 4 * (z - m.zmax / 2)^2 + ε1
    ρv = 1 - 4 * (z - m.zmax / 2)^2 + ε2
    ρw = 0
    state.ρu = SVector(ρu, ρv, ρw)

    state.ρcT = state.ρ * m.c * aux.T
end;</code></pre><p>The remaining methods, defined in this section, are called at every time-step in the solver by the <a href="../../../APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.BalanceLaw"><code>BalanceLaw</code></a> framework.</p><p>Overload <code>update_auxiliary_state!</code> to call <code>heat_eq_nodal_update_aux!</code>, or any other auxiliary methods</p><pre><code class="language-julia">function update_auxiliary_state!(
    dg::DGModel,
    m::BurgersEquation,
    Q::MPIStateArray,
    t::Real,
    elems::UnitRange,
)
    nodal_update_auxiliary_state!(heat_eq_nodal_update_aux!, dg, m, Q, t, elems)
    return true # TODO: remove return true
end;</code></pre><p>Compute/update all auxiliary variables at each node. Note that</p><ul><li><code>aux.T</code> is available here because we&#39;ve specified <code>T</code> in</li></ul><p><code>vars_state</code></p><pre><code class="language-julia">function heat_eq_nodal_update_aux!(
    m::BurgersEquation,
    state::Vars,
    aux::Vars,
    t::Real,
)
    aux.T = state.ρcT / (state.ρ * m.c)
end;</code></pre><p>Since we have second-order fluxes, we must tell <code>ClimateMachine</code> to compute the gradient of <code>ρcT</code> and <code>u</code>. Here, we specify how <code>ρcT</code>, <code>u</code> are computed. Note that <code>transform.ρcT</code> and <code>transform.u</code> are available here because we&#39;ve specified <code>ρcT</code> and <code>u</code>in <code>vars_state</code></p><pre><code class="language-julia">function compute_gradient_argument!(
    m::BurgersEquation,
    transform::Vars,
    state::Vars,
    aux::Vars,
    t::Real,
)
    transform.ρcT = state.ρcT
    transform.u = state.ρu / state.ρ
end;</code></pre><p>Specify where in <code>diffusive::Vars</code> to store the computed gradient from <code>compute_gradient_argument!</code>. Note that:</p><ul><li><code>diffusive.μ∇u</code> is available here because we&#39;ve specified <code>μ∇u</code> in</li></ul><p><code>vars_state</code></p><ul><li><code>∇transform.u</code> is available here because we&#39;ve specified <code>u</code> in</li></ul><p><code>vars_state</code></p><ul><li><code>diffusive.μ∇u</code> is built using an anisotropic diffusivity tensor</li></ul><pre><code class="language-julia">function compute_gradient_flux!(
    m::BurgersEquation,
    diffusive::Vars,
    ∇transform::Grad,
    state::Vars,
    aux::Vars,
    t::Real,
)
    diffusive.α∇ρcT = m.α * ∇transform.ρcT
    diffusive.μ∇u = Diagonal(SVector(m.μh, m.μh, m.μv)) * ∇transform.u
end;</code></pre><p>Introduce Rayleigh friction towards a target profile as a source. Note that:</p><ul><li>Rayleigh damping is only applied in the horizontal by subtracting</li></ul><p>the vertical component of momentum from the momentum vector.</p><pre><code class="language-julia">function source!(
    m::BurgersEquation{FT},
    source::Vars,
    state::Vars,
    diffusive::Vars,
    aux::Vars,
    args...,
) where {FT}
    ẑ = SVector{3, FT}(0, 0, 1)
    ρ̄ū =
        state.ρ * SVector{3, FT}(
            0.5 - 2 * (aux.z - m.zmax / 2)^2,
            0.5 - 2 * (aux.z - m.zmax / 2)^2,
            0.0,
        )
    ρu_p = state.ρu - ρ̄ū
    source.ρu -= m.γ * (ρu_p - ẑ&#39; * ρu_p * ẑ)
end;</code></pre><p>Compute advective flux. Note that:</p><ul><li><code>state.ρu</code> is available here because we&#39;ve specified <code>ρu</code> in</li></ul><p><code>vars_state</code></p><pre><code class="language-julia">function flux_first_order!(
    m::BurgersEquation,
    flux::Grad,
    state::Vars,
    aux::Vars,
    t::Real,
    _...,
)
    flux.ρ = state.ρu

    u = state.ρu / state.ρ
    flux.ρu = state.ρu * u&#39;
    flux.ρcT = u * state.ρcT
end;</code></pre><p>Compute diffusive flux (e.g. <span>$F(μ, \mathbf{u}, t) = -μ∇\mathbf{u}$</span> in the original PDE). Note that:</p><ul><li><code>diffusive.μ∇u</code> is available here because we&#39;ve specified <code>μ∇u</code> in</li></ul><p><code>vars_state</code></p><pre><code class="language-julia">function flux_second_order!(
    m::BurgersEquation,
    flux::Grad,
    state::Vars,
    diffusive::Vars,
    hyperdiffusive::Vars,
    aux::Vars,
    t::Real,
)
    flux.ρcT -= diffusive.α∇ρcT
    flux.ρu -= diffusive.μ∇u
end;</code></pre><h3 id="Boundary-conditions-1"><a class="docs-heading-anchor" href="#Boundary-conditions-1">Boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions-1" title="Permalink"></a></h3><p>Second-order terms in our equations, <span>$∇⋅(G)$</span> where <span>$G = μ∇\mathbf{u}$</span>, are internally reformulated to first-order unknowns. Boundary conditions must be specified for all unknowns, both first-order and second-order unknowns which have been reformulated.</p><p>The boundary conditions for <code>ρ</code>, <code>ρu</code> and <code>ρcT</code> (first order unknown)</p><pre><code class="language-julia">function boundary_state!(
    nf,
    m::BurgersEquation,
    state⁺::Vars,
    aux⁺::Vars,
    n⁻,
    state⁻::Vars,
    aux⁻::Vars,
    bctype,
    t,
    _...,
)
    if bctype == 1 # bottom
        state⁺.ρ = 1
        state⁺.ρu = SVector(0, 0, 0)
        state⁺.ρcT = state⁺.ρ * m.c * m.T_bottom
    elseif bctype == 2 # top
        state⁺.ρ = 1
        state⁺.ρu = SVector(0, 0, 0)
    end
end;</code></pre><p>The boundary conditions for <code>ρ</code>, <code>ρu</code> and <code>ρcT</code> are specified here for second-order unknowns</p><pre><code class="language-julia">function boundary_state!(
    nf,
    m::BurgersEquation,
    state⁺::Vars,
    diff⁺::Vars,
    aux⁺::Vars,
    n⁻,
    state⁻::Vars,
    diff⁻::Vars,
    aux⁻::Vars,
    bctype,
    t,
    _...,
)
    if bctype == 1 # bottom
        state⁺.ρ = 1
        state⁺.ρu = SVector(0, 0, 0)
        state⁺.ρcT = state⁺.ρ * m.c * m.T_bottom
    elseif bctype == 2 # top
        state⁺.ρ = 1
        state⁺.ρu = SVector(0, 0, 0)
        diff⁺.α∇ρcT = -n⁻ * m.flux_top
    end
end;</code></pre><h1 id="Spatial-discretization-1"><a class="docs-heading-anchor" href="#Spatial-discretization-1">Spatial discretization</a><a class="docs-heading-anchor-permalink" href="#Spatial-discretization-1" title="Permalink"></a></h1><p>Prescribe polynomial order of basis functions in finite elements</p><pre><code class="language-julia">N_poly = 5;</code></pre><p>Specify the number of vertical elements</p><pre><code class="language-julia">nelem_vert = 20;</code></pre><p>Specify the domain height</p><pre><code class="language-julia">zmax = m.zmax;</code></pre><p>Establish a <code>ClimateMachine</code> single stack configuration</p><pre><code class="language-julia">driver_config = ClimateMachine.SingleStackConfiguration(
    &quot;BurgersEquation&quot;,
    N_poly,
    nelem_vert,
    zmax,
    param_set,
    m,
    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),
);</code></pre><pre><code class="language-none">┌ Info: Model composition
│     param_set = Main.ex-burgers_single_stack.EarthParameterSet()
│     c = 1.0
│     μv = 0.0001
│     μh = 0.01
│     α = 0.01
│     σ = 0.1
│     γ = 1250.0
│     zmax = 1.0
│     initialT = 295.15
│     T_bottom = 300.0
└     flux_top = 0.0
┌ Info: Establishing single stack configuration for BurgersEquation
│     precision        = Float64
│     polynomial order = 5
│     domain_min       = 0.00 m x0.00 m x0.00 m
│     domain_max       = 1.00 m x1.00 m x1.00 m
│     #vert elems      = 20
│     MPI ranks        = 1
│     min(Δ_horz)      = 0.12 m
└     min(Δ_vert)      = 0.01 m</code></pre><h1 id="Time-discretization-1"><a class="docs-heading-anchor" href="#Time-discretization-1">Time discretization</a><a class="docs-heading-anchor-permalink" href="#Time-discretization-1" title="Permalink"></a></h1><p>Specify simulation time (SI units)</p><pre><code class="language-julia">t0 = FT(0)
timeend = FT(10)</code></pre><pre><code class="language-none">10.0</code></pre><p>We&#39;ll define the time-step based on the [Fourier number] and the [Courant number] of the flow</p><pre><code class="language-julia">Δ = min_node_distance(driver_config.grid)

given_Fourier = FT(0.08);
Fourier_bound = given_Fourier * Δ^2 / max(m.α, m.μh);
Courant_bound = FT(0.1) * Δ
dt = min(Fourier_bound, Courant_bound)</code></pre><pre><code class="language-none">0.0002759950040694205</code></pre><h1 id="Configure-a-ClimateMachine-solver.-1"><a class="docs-heading-anchor" href="#Configure-a-ClimateMachine-solver.-1">Configure a <code>ClimateMachine</code> solver.</a><a class="docs-heading-anchor-permalink" href="#Configure-a-ClimateMachine-solver.-1" title="Permalink"></a></h1><p>This initializes the state vector and allocates memory for the solution in space (<code>dg</code> has the model <code>m</code>, which describes the PDEs as well as the function used for initialization). This additionally initializes the ODE solver, by default an explicit Low-Storage <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta</a> method.</p><pre><code class="language-julia">solver_config =
    ClimateMachine.SolverConfiguration(t0, timeend, driver_config, ode_dt = dt);</code></pre><pre><code class="language-none">[ Info: Initializing BurgersEquation</code></pre><h2 id="Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1"><a class="docs-heading-anchor" href="#Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1">Inspect the initial conditions for a single node (e.g. the southwest node)</a><a class="docs-heading-anchor-permalink" href="#Inspect-the-initial-conditions-for-a-single-node-(e.g.-the-southwest-node)-1" title="Permalink"></a></h2><p>Let&#39;s export a plot of the initial state</p><pre><code class="language-julia">output_dir = @__DIR__;

mkpath(output_dir);

z_scale = 100 # convert from meters to cm
z_key = &quot;z&quot;
z_label = &quot;z [cm]&quot;
z = get_z(driver_config.grid, z_scale)
state_vars = get_vars_from_nodal_stack(
    driver_config.grid,
    solver_config.Q,
    vars_state(m, Prognostic(), FT),
    i = 1,
    j = 1,
);
aux_vars = get_vars_from_nodal_stack(
    driver_config.grid,
    solver_config.dg.state_auxiliary,
    vars_state(m, Auxiliary(), FT),
    i = 1,
    j = 1,
    exclude = [z_key],
);
all_vars = OrderedDict(state_vars..., aux_vars...);</code></pre><p>Generate plots of initial conditions</p><pre><code class="language-julia">export_plot_snapshot(
    z,
    all_vars,
    (&quot;ρcT&quot;,),
    joinpath(output_dir, &quot;initial_condition_T.png&quot;),
    z_label,
);
export_plot_snapshot(
    z,
    all_vars,
    (&quot;ρu[1]&quot;,),
    joinpath(output_dir, &quot;initial_condition_u.png&quot;),
    z_label,
);
export_plot_snapshot(
    z,
    all_vars,
    (&quot;ρu[2]&quot;,),
    joinpath(output_dir, &quot;initial_condition_v.png&quot;),
    z_label,
);</code></pre><h2 id="Inspect-the-initial-conditions-for-the-horizontal-average-1"><a class="docs-heading-anchor" href="#Inspect-the-initial-conditions-for-the-horizontal-average-1">Inspect the initial conditions for the horizontal average</a><a class="docs-heading-anchor-permalink" href="#Inspect-the-initial-conditions-for-the-horizontal-average-1" title="Permalink"></a></h2><p>Horizontal statistics of variables</p><pre><code class="language-julia">state_vars_var = get_horizontal_variance(
    driver_config.grid,
    solver_config.Q,
    vars_state(m, Prognostic(), FT),
);

state_vars_avg = get_horizontal_mean(
    driver_config.grid,
    solver_config.Q,
    vars_state(m, Prognostic(), FT),
);

export_plot_snapshot(
    z,
    state_vars_avg,
    (&quot;ρu[1]&quot;,),
    joinpath(output_dir, &quot;initial_condition_avg_u.png&quot;),
    z_label,
);
export_plot_snapshot(
    z,
    state_vars_var,
    (&quot;ρu[1]&quot;,),
    joinpath(output_dir, &quot;initial_condition_variance_u.png&quot;),
    z_label,
);</code></pre><p><img src="../initial_condition_avg_u.png" alt/> <img src="../initial_condition_variance_u.png" alt/></p><h1 id="Solver-hooks-/-callbacks-1"><a class="docs-heading-anchor" href="#Solver-hooks-/-callbacks-1">Solver hooks / callbacks</a><a class="docs-heading-anchor-permalink" href="#Solver-hooks-/-callbacks-1" title="Permalink"></a></h1><p>Define the number of outputs from <code>t0</code> to <code>timeend</code></p><pre><code class="language-julia">const n_outputs = 5;</code></pre><p>This equates to exports every ceil(Int, timeend/n_outputs) time-step:</p><pre><code class="language-julia">const every_x_simulation_time = ceil(Int, timeend / n_outputs);</code></pre><p>Create a dictionary for <code>z</code> coordinate (and convert to cm) NCDatasets IO:</p><pre><code class="language-julia">dims = OrderedDict(z_key =&gt; collect(z));

data_var = Dict[Dict([k =&gt; Dict() for k in 0:n_outputs]...),]
data_var[1] = state_vars_var

data_avg = Dict[Dict([k =&gt; Dict() for k in 0:n_outputs]...),]
data_avg[1] = state_vars_avg</code></pre><pre><code class="language-none">OrderedCollections.OrderedDict{Any,Any} with 5 entries:
  &quot;ρ&quot;     =&gt; [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.…
  &quot;ρu[1]&quot; =&gt; [-0.0196029, 0.0364377, 0.0939595, 0.126314, 0.143579, 0.200895, 0…
  &quot;ρu[2]&quot; =&gt; [0.00992096, 0.00711187, 0.0678314, 0.1328, 0.140056, 0.213045, 0.…
  &quot;ρu[3]&quot; =&gt; [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.…
  &quot;ρcT&quot;   =&gt; [295.15, 295.15, 295.15, 295.15, 295.15, 295.15, 295.15, 295.15, 2…</code></pre><p>The <code>ClimateMachine</code>&#39;s time-steppers provide hooks, or callbacks, which allow users to inject code to be executed at specified intervals. In this callback, the state and aux variables are collected, combined into a single <code>OrderedDict</code> and written to a NetCDF file (for each output step <code>step</code>).</p><pre><code class="language-julia">step = [0];
callback = GenericCallbacks.EveryXSimulationTime(every_x_simulation_time) do
    state_vars_var = get_horizontal_variance(
        driver_config.grid,
        solver_config.Q,
        vars_state(m, Prognostic(), FT),
    )
    state_vars_avg = get_horizontal_mean(
        driver_config.grid,
        solver_config.Q,
        vars_state(m, Prognostic(), FT),
    )
    step[1] += 1
    push!(data_var, state_vars_var)
    push!(data_avg, state_vars_avg)
    nothing
end;</code></pre><h1 id="Solve-1"><a class="docs-heading-anchor" href="#Solve-1">Solve</a><a class="docs-heading-anchor-permalink" href="#Solve-1" title="Permalink"></a></h1><p>This is the main <code>ClimateMachine</code> solver invocation. While users do not have access to the time-stepping loop, code may be injected via <code>user_callbacks</code>, which is a <code>Tuple</code> of <a href="../../../APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks"><code>GenericCallbacks</code></a>.</p><pre><code class="language-julia">ClimateMachine.invoke!(solver_config; user_callbacks = (callback,))</code></pre><pre><code class="language-none">1.0058697196640842</code></pre><h1 id="Post-processing-1"><a class="docs-heading-anchor" href="#Post-processing-1">Post-processing</a><a class="docs-heading-anchor-permalink" href="#Post-processing-1" title="Permalink"></a></h1><p>Our solution has now been calculated and exported to NetCDF files in <code>output_dir</code>.</p><p>Let&#39;s plot the horizontal statistics of the solution:</p><pre><code class="language-julia">export_plot(
    z,
    data_avg,
    (&quot;ρu[1]&quot;),
    joinpath(output_dir, &quot;solution_vs_time_u.png&quot;),
    z_label,
    xlabel = &quot;Horizontal mean rho*u&quot;,
);
export_plot(
    z,
    data_var,
    (&quot;ρu[1]&quot;),
    joinpath(output_dir, &quot;variance_vs_time_u.png&quot;),
    z_label,
    xlabel = &quot;Horizontal variance rho*u&quot;,
);
export_plot(
    z,
    data_avg,
    (&quot;ρcT&quot;),
    joinpath(output_dir, &quot;solution_vs_time_T.png&quot;),
    z_label,
    xlabel = &quot;Horizontal mean rho*c*T&quot;,
);
export_plot(
    z,
    data_var,
    (&quot;ρu[3]&quot;),
    joinpath(output_dir, &quot;variance_vs_time_w.png&quot;),
    z_label,
    xlabel = &quot;Horizontal variance rho*w&quot;,
);</code></pre><p><img src="../solution_vs_time_u.png" alt/> <img src="../variance_vs_time_u.png" alt/></p><p>The results look as we would expect: they Rayleigh friction damps the horizontal velocity to the objective profile and the horizontal diffusivity damps the horizontal variance. To run this file, and inspect the solution, include this tutorial in the Julia REPL with:</p><pre><code class="language-julia">include(joinpath(&quot;tutorials&quot;, &quot;Atmos&quot;, &quot;burgers_single_stack.jl&quot;))</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../heldsuarez/">« Dry Idealized GCM</a><a class="docs-footer-nextpage" href="../agnesi_hs_lin/">Linear Hydrostatic Mountain (Topography) »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 July 2020 00:37">Thursday 23 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
